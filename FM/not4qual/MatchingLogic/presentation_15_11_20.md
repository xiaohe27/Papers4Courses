---
author: Everett Hildenbrandt
title: Matching Logic
subtitle: Grigore Rosu
format: beamer
theme: Berkeley
fontsize: 9pt
header-includes:
-   \newcommand\restr[2]{{\left.\kern-\nulldelimiterspace#1\vphantom{\big|}\right|_{#2}}}
...


Motivation
==========

Separation Logic[@separationlogic]
----------------------------------

### Just Add Logic!

Separation logic allows reasoning about small "heaplets" at a time, which
simplifies the formulae for proving properties of programs. It does this by
introducing several things into the logic itself, listed here:

-   Theories of integers and booleans
-   Memory maps - $E \mapsto F$
-   Predicates $\texttt{isatom?}(E)$ and $\texttt{isloc?}(E)$
-   Spatial connectives `emp`, $P * Q$, $P \leadsto Q$

### Matching Logic

-   Separation logic expressible without extra primitives in matching logic.
-   Reasoning about locations, values, and storage left to programming language
    semantics.

Matching Logic[@matchinglogic][@matchinglogicabstract]
------------------------------------------------------

### No Extra Logic

Separation logic isn't the only culprit of the "Just Add Logic!" camp. Matching
logic allows for reasoning about *anything* structured without adding to
matching logic itself. Thus, matching logic's sound and complete proof system
can be used for *any* programming language without modification.

### Clean Syntactic Reasoning

Matching logic also lends itself well to syntactic execution.[^rewriting]

-   Patterns specify sets of elements from a model.
-   No need to generate the sets of elements; the pattern itself suffices for
    reasoning and execution.
-   Ex: pattern $\exists x . succ(x)$ grabs all the elements that can be
    generated by the $succ$ symbol.

[^rewriting]: Because we can reason about matching logic using only the syntax
    of matching logic expressions, we can write down its proof system as a
    rewriting logic specification. Rewriting logic is a logic of execution.


Examples
========

Peano Naturals
--------------

### Signature $(S, \Sigma)$

$S$:
:   $\{Nat\}$

$\Sigma$:
:   $\{0_{Nat}, succ_{Nat, Nat}, plus_{Nat \times Nat, Nat}\}$

$Var$:
:   $\{x_{Nat}, y_{Nat}, z_{Nat}\}$

### Axioms $F$

In order to specify *exactly* the Peano Naturals, we add axioms $F$ that an
admissible model $M$ must satisfy, $M \models F$.

$0$ total func:
:   $\exists y . 0 = y$

$succ$ total func:
:   $\exists y . succ(x) = y$

$succ$ inj. func:
:   $succ(x) = succ(y) \rightarrow x = y$

Only $0$ or $succ$:
:   $0 \lor \exists x . succ(x)$

$plus$ defn:
:   $plus(x, y) = (x = 0 \land y
                    \lor \exists z . succ(z) = x \land succ(plus(z,y)))$

The *matching logic specification* is the triple $(S, \Sigma, F)$.

Lists and Memory Maps
---------------------

### Signature $(S, \Sigma)$

$S$:
:   $\{Nat, Seq, Map\}$

$\Sigma$:
:   $\{\epsilon_{Seq},
        \quad emp_{Map},
        \quad \_\cdot\__{Nat \times Seq,Seq},$  
    $\_\mapsto\__{Nat \times Nat,Map},
        \quad \_\mapsto[\_]_{Nat \times Seq,Map}$  
    $\_*\__{Map \times Map,Map},
        \quad list_{Nat \times Seq,Map}\}$

$Var$:
:   $\{a_{Nat}, b_{Nat}, S_{Seq}\} \cup Var_{Peano}$

### Axioms $F$

$0$ not key:
:   $\lnot (0 \mapsto a)$

Unique keys:
:   $(x \mapsto a * y \mapsto b) \rightarrow x \neq y$

Empty $Map$:
:   $x \mapsto [\epsilon] = emp$

$Map$ "cons":
:   $x \mapsto [a \cdot S] = x \mapsto a * succ(x) \mapsto [S]$

Empty $list$:
:   $list(0, \epsilon) = emp$

$list$ "cons":
:   $list(x, a \cdot S) = \exists z . x \mapsto [a \cdot z \cdot \epsilon] *
        list(z, S)$

Our specification is $(S \cup S_{Peano}, \Sigma \cup \Sigma_{Peano}, F \cup
F_{Peano})$.


Definitions
===========

Signatures and Patterns
-----------------------

### Signature $(S, \Sigma)$ and Variables

$S$:
:   Set of sorts

$\Sigma$:
:   Sort-indexed set of symbols
    $\Sigma = \{\Sigma_{s_1...s_n,s}\}_{s_1,...,s_n,s \in S}$

$Var$:
:   Sort-indexed set of symbols $Var = \{Var_s\}_{s \in S}$

### Patterns (Formulae) $\phi_s$

$\phi_s$:
:   $x \in Var_s
    \mid \sigma(\phi_{s_1},...,\phi_{s_n})
    \mid \lnot \phi_s
    \mid \phi_s \land \phi_s
    \mid \exists y . \phi_s$  
    with $\sigma(\phi_{s_1},...,\phi_{s_n}) \in \Sigma_{s_1...s_n,s}$
        and $y \in Var$

    -   $x : s \equiv x \in Var_s$
    -   $\bot_s \equiv x:s \land \lnot x:s$ \qquad $\top_s \equiv \lnot \bot_s$
    -   $\lor$, $\rightarrow$, $\leftrightarrow$, and $\forall$ defined in the
        normal FOL ways.

$PATTERN$:
:   Sort-indexed set of patterns $PATTERN = \{PATTERN_s\}_{s \in S}$. We can say
    $\phi_s \in PATTERN_s$.

Models and $M$-valuations
-------------------------

### $(S, \Sigma)$ Model $M$

Carrier set $M$[^nonemptyMs]:
:   Sort-indexed set $\{M_s\}_{s \in S}$ is *carrier set of sort $s$ in $M$*.

Functions $\sigma_M$:
:   For each $\sigma_{s_1...s_n,s} \in \Sigma$, define a function $\sigma_M :
    M_{s_1} \times...\times M_{s_n} \to \mathcal{P}(M_s)$, the *interperetation
    of $\sigma$ in $M$*.

    We may smoothly and usefully say that $\sigma_M(A_1,...,A_n) = \cup
    \{\sigma_M(a_1,...,a_n) \mid a_1 \in A_1,...,a_n \in A_n\}$  with $A_1
    \subseteq M_{s_1},...,A_n \subseteq M_{s_n}$.

[^nonemptyMs]: With restriction $M_s \neq \emptyset$ for all $s \in S$.

### $M$-valuation $\rho$

$M$-valuation $\rho$:
:   $\rho : Var \to M$ selects an element $m \in M_s$ for each $x \in Var_s$.

Extension to $\overline{\rho}$:
:   $\overline{\rho} : PATTERN \to \mathcal{P}(M)$ returns elements of $M$ which
    "match" the given pattern with $M$-valuation $\rho$.

Pattern Matching
----------------

We have defined the $M$-valuation $\rho : Var \to M$, and hinted at its
extension $\overline{\rho} : PATTERN \to \mathcal{P}(M)$. Intuitively,
$\overline{\rho}$ takes a pattern $\phi_s$ and returns all elements of $M_s$
which match the pattern given $\rho$.

### Definition of $\overline{\rho}$

$\overline{\rho}$ is defined recursively on the structure of patterns $\phi_s$.

-   $\overline{\rho}(x) = \{\rho(x)\}$, for $x \in Var$

-   $\overline{\rho}(\lnot\phi_s) = M_s \setminus \overline{\rho}(\phi_s)$

-   $\overline{\rho}(\sigma(\phi_1,...,\phi_n))
        = \sigma_M(\overline{\rho}(\phi_1),...,\overline{\rho}(\phi_n))$

-   $\overline{\rho}(\phi_1 \land \phi_2)
        = \overline{\rho}(\phi_1) \cap \overline{\rho}(\phi_2)$

-   $\overline{\rho}(\exists x . \phi)
        = \cup  \{\overline{\rho'}(\phi)
                    \mid \rho' : Var \to M
                    , \restr{\rho'}{FV(\phi)\setminus\{x\}}
                    = \restr{\rho}{FV(\phi)\setminus\{x\}}
                \}$

$M_s \setminus \overline{\rho}(\phi_s)$ is
    *set difference $\{m \in M_s \mid m \notin \overline{\rho}(\phi_s)\}$*.  
$\restr{\rho}{FV(\phi)}$ is
    *$\rho$ with domain restricted to free vars of $\phi$*.

Satisfaction and Matching Logic Specification
---------------------------------------------

### Model Satisfaction $M \models \phi_s$

*$M$ satisfies $\phi_s$*:
:   $M \models \phi_s$
        iff $\overline{\rho}(\phi_s) = M_s$ for all $\rho : Var \to M$.

    -   What does $M \models x$ mean?
    -   And $M \models \exists x . \sigma(\phi_1,x) \lor \lnot \phi_2$?

*$\phi_s$ valid*:
:   $\models \phi_s$ iff $M \models \phi_s$ for all $M$.

*$M$ satisfies $F$*:
:   $M \models F$ for $F \subseteq PATTERN$
        iff $M \models \phi$ for all $\phi \in F$.

*$F$ entails $\phi$*:
:   $F \models \phi$ iff $M \models F$ implies $M \models \phi$.

### Matching Logic Specification $(S, \Sigma, F)$

A *matching logic specification* $(S, \Sigma, F)$ is $S$ a set of sorts,
$\Sigma$ a set of sort-indexed symbols, and $F$ a set of patterns.

Pattern Equality
----------------

### $M \models \phi_1 = \phi_2$

Equality in matching logic acts as a predicate on the patterns being tested.
Two patterns $\phi_1$ and $\phi_2$ should be equal in a model when they always
produce the same elements from the model's carrier set, regardless of $\rho$.

$$\overline{\rho}(\phi_1 = \phi_2)
    = M \texttt{ if } (\overline{\rho}(\phi_1) = \overline{\rho}(\phi_2)
                        \texttt{ for all } \rho)
        \texttt{ else } \emptyset$$

### What about $M \models \phi_1 \leftrightarrow \phi_2$?

Consider for example the case of natural numbers - what interperatations does
the axiom $\exists y . succ(x) \leftrightarrow y$ allow for $succ_M$? It
actually allows for $succ$ to be a total, partial, or non-function!

We need the stronger $=$, with the axiom $\exists y . succ(x) = y$, to specify
that $succ$ is actually a total function.


Deduction
=========

Proof System
------------

### FOL Axioms and Rules

-   $\vdash$ propositional tautologies
-   Modus ponens: $\vdash \phi_1$ and $\vdash \phi_1 \rightarrow \phi_2$ imply
    $\vdash \phi_2$
-   $\vdash (\forall x . \phi_1 \rightarrow \phi_2) \rightarrow (\phi_1
    \rightarrow \forall x . \phi_2)$ when $x \notin FV(\phi_1)$
-   Universal generalization: $\vdash \phi$ implies $\vdash \forall x . \phi$
-   Substitution: $\vdash (\forall x . \phi) \land (\exists y . \phi' = y)
    \rightarrow \phi[\phi'/x]$
-   Equality introduction: $\vdash \phi = \phi$
-   Equality elimination: $\vdash \phi_1 = \phi_2 \land \phi[\phi_1/x]
    \rightarrow \phi[\phi_2/x]$

### Membership Axioms and Rules

-   $\vdash \forall x . x \in \phi$ iff $\vdash \phi$
-   $\vdash x \in y = (x = y)$ when $x, y \in Var$
-   $\vdash x \in \lnot \phi = \lnot (x \in \phi)$
-   $\vdash x \in \phi_1 \land \phi_2 = (x \in \phi_1) \land (x \in \phi_2)$
-   $\vdash (x \in \exists y . \phi) = \exists y . (x \in \phi)$ with $x$ and
    $y$ distinct
-   $\vdash x \in \sigma(\phi_1,...,\phi_{i-1},\phi_i,\phi_{i+1},...,\phi_n) =
    \exists y . (y \in \phi_i \land x \in
    \sigma(\phi_1,...,\phi_{i-1},y,\phi_{i+1},...\phi_n))$


Conclusion
==========

Matching Logic
--------------

### Has

-   Sound and complete proof system of its own.
-   Intuitive reductions to predicate logic and first order logic with equality.
-   Good executability properties.

### Doesn't Have

-   Extra symbols or definitions specific to the programming language (or
    structure) that you are reasoning about.
-   Restrictions on the types of structure you can reason about.

References
----------

Thanks for listening everyone!

---
references:
-   id: separationlogic
    author:
    -   family: O\'Hearn
        given: Peter
    -   family: Reynolds
        given: John
    -   family: Yang
        given: Hongseok
    issued:
    -   year: '2001'
    title: Local reasoning about programs that alter data structures
-   id: matchinglogic
    author:
    -   family: Rosu
        given: Grigore
    issued:
    -   year: '2014'
    title: Matching Logic - A Logic for Structural Reasoning
-   id: matchinglogicabstract
    author:
    -   family: Rosu
        given: Grigore
    issued:
    -   year: '2015'
    title: Matching Logic - Extended Abstract
csl: ieee.csl
...
